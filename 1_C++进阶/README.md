# C++基础

> 关于C++进阶部分的文件目录


## 目录

- [函数模板](#函数模板)
- [类型转换](#类型转换)
- [异常处理机制](#异常处理机制)
- [C++的输入输出流](#C++的输入输出流)

## 函数模板

- [函数模板基本语法](00_函数模板/00_函数模板基本语法.cpp)
  - 模板函数定义声明`template <typename T>`
  - 显示类型转换`Swap<int>(a, b);`
  - 隐式类型转换`int a; int b;`  `Swap(a, b);`
  - 函数模板本质:类型参数化

- [函数模板做函数参数](00_函数模板/01_函数模板做函数参数.cpp)
  - `template <typename T, typename T2>`  `void Sort(T* array, T2 size)`
  - `Sort<int, int>(array, size);`
  
- [模板函数遇上函数重载](00_函数模板/02_模板函数遇上函数重载.cpp)
  - 模板函数有极其严格的类型检查,不允许自动类型转换
  - 普通函数类型检查相对宽松，可以进行隐式类型转换
  - 模板函数可以像普通函数一样被重载
  - C++编译器优先考虑普通函数
  - 如果模板函数可以产生一个更好的匹配，则选择模板函数
  - 可以通过空模板实参列表的语法限制编译器选择模板函数匹配

- [模板函数本质剖析](00_函数模板/03_模板函数本质剖析.cpp)
  - 函数模板本质剖析
  - 编译器并不是把模板函数编译成能处理任何类的函数
  - 编译器从模板函数通过具体类型产生不同函数
  - 编译器会对模板函数进行两次编译！！！
    - 在声明的地方对代码本身进行编译，在调用的地方对参数替换后的代码进行编译

- [类模板基本语法](00_函数模板/04_类模板基本语法.cpp)
  - 类模板声明
    - `template <typename Type>`
    - `class Test`
  - 类模板定义: 类模板是抽象的  需要具体化
	- `Test <int> a1(10), a2(20), a3(30);  // 类模板使用 必须初始化参数`
  - 类模板做函数参数 也需要具体化
    - `void useTest(Test <int> a)`

- [模板类派生普通类和模板类](00_函数模板/05_模板类派生普通类.cpp)
  - 需要模板类具体化，子类必须知道为父类分配多大内存空间
  - `class TestB : public Test<int>`

- 类模板的应用-复数类的实现
  - [模板类的方法都写在类的内部](00_函数模板/06_复数类_所有类的方法都在写类的内部.cpp)
  - [模板函数方法写在类的外部同一个cpp文件中](00_函数模板/06_复数类_模板类方法的外部实现_一个cpp中.cpp)
    - 友元函数重载模板类操作符的解决方法
    - 模板类友元函数滥用编译出错解决方法
  - [模板函数方法写在类的外部_h_hpp文件中](00_函数模板/07_模板类的外部实现_h_hpp.cpp)
    - 主调文件中需要包含cpp文件，改名hpp
    - 尽量写到一个文件中

- [类模板中的static关键字](00_函数模板/08_static关键字遇上模板类.cpp)
  - 模板类的静态成员变量每个类都拥有自己的静态成员变量(模板类的编译机制吻合)

- [MyVector实现](00_函数模板/09_MyVector_Test.cpp)
  - 初步实现
  - 存储复杂数据类型(类、类(含有指针变量)、类的指针)

## 类型转换

- [C++与C中的类型转换](01_类型转换/00_C++与C语言中的类型转换.cpp)
  - C 语言中的类型转换：（强制类型转换）
	  - `TYPE b = (TYPE) a;`
  - C++ 语言中的类型转换：（4种、应对不同场合）
	  - 1 `static_cast`
		  - 静态类型转换所有C语言支持都不会报错， 不支持的会报错
	  - 2 `reinterpret_cast`
		  - 重新解释类型
	  - 3 `dynamic_cast`
		  - 动态类型转换， 如父类和子类之间的动态类型转换
	  - 4 `const_cast`
		  - 去 const 属性

## 异常处理机制

- [异常基本语法](02_异常处理机制/00_异常处理的基本语法.cpp)
  - 异常的基本语法
  - 异常跨函数
  - 接收异常之后可以不处理， 继续向上抛出
  - 异常的cacht严格遵守类型匹配
  - 异常的处理机制使得错误的引发和处理不必在同一个函数中进行， 实现软件分层

- [栈解旋unwimding](02_异常处理机制/01_栈解旋unwimding.cpp)
  - 从进入try语句到发生异常的语句之前所有栈变量都将被析构，析构顺序与构造顺序相反
  - 异常接口声明
    - 写了， 只能抛出列表异常`void voidTest4() throw(int , char , char *)`
    - 不写，可以抛出任何类型异常`void voidTest5() `
    - 异常列表为空， 不抛出任何类型异常`void voidTest5() throw()`

- [异常变量的生命周期](02_异常处理机制/02_异常变量的生命周期.cpp)
  - C++异常处理机制 int 、const char * 
  - C++异常处理机制 类对象异常
    - `throw ErrorTest();`捕捉变量|引用 注意特殊写法, 创建匿名对象
      - 1 捕捉变量异常变量时利用匿名对象拷贝构造异常变量
      - 2 捕捉引用异常变量会使用 throw 的匿名对象
    - `throw &(ErrorTest());`  捕捉指针异常变量  返回时析构，返回野指针 ERROR
		- `throw new ErrorTest; `  捕捉指针异常变量  放到堆上
      - 3 为避免野指针， 异常变量放在堆上
      - `delete e; `  释放空间， 避免内存泄漏
    - 指针异常变量的捕捉与变量或者引用可以同时存在， 引用个变量不能同时存在
    - 结论：类对象使用引用能避免麻烦，提高效率

- [异常的层次结构（异常类继承）](02_异常处理机制/03_异常的层次结构_继承中的异常类.cpp)

- [标准异常库](02_异常处理机制/04_C++exception类.cpp)
  - [C++异常类继承图](02_异常处理机制/04_C++异常类继承图.png)
  - [异常类具体信息](02_异常处理机制/04_异常类具体信息.md)
  - 标准异常库的使用和继承

## C++的输入输出流
- [输入输出流结构](03_C++输入输出流/流类库结构.md)

- [标准io输入cin](03_C++输入输出流/00_cinAPI.cpp)
  - `cin.get()`获取一个字符
  - `cin.get(一个参数)`获取一个字符到参数变量
  - `cin.get(三个参数)`获取一个串，遇到空格停止
  - `cin.getline(buf2, 256);`获取一个串，可以接受空格
  - `cin.ignore(2); `忽略字符
  - `Test = cin.peek();`查看缓冲区是否有数据，如果有则读出数据， 没有返回0
	
	