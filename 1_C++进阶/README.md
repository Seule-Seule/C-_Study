# C++基础

> 关于C++进阶部分的文件目录


## 目录

- [函数模板](#函数模板)

## 函数模板

- [函数模板基本语法](00_函数模板/00_函数模板基本语法.cpp)
  - 模板函数定义声明`template <typename T>`
  - 显示类型转换`Swap<int>(a, b);`
  - 隐式类型转换`int a; int b;`  `Swap(a, b);`
  - 函数模板本质:类型参数化

- [函数模板做函数参数](00_函数模板/01_函数模板做函数参数.cpp)
  - `template <typename T, typename T2>`  `void Sort(T* array, T2 size)`
  - `Sort<int, int>(array, size);`
  
- [模板函数遇上函数重载](00_函数模板/02_模板函数遇上函数重载.cpp)
  - 模板函数有极其严格的类型检查,不允许自动类型转换
  - 普通函数类型检查相对宽松，可以进行隐式类型转换
  - 模板函数可以像普通函数一样被重载
  - C++编译器优先考虑普通函数
  - 如果模板函数可以产生一个更好的匹配，则选择模板函数
  - 可以通过空模板实参列表的语法限制编译器选择模板函数匹配

- [模板函数本质剖析](00_函数模板/03_模板函数本质剖析.cpp)
  - 函数模板本质剖析
  - 编译器并不是把模板函数编译成能处理任何类的函数
  - 编译器从模板函数通过具体类型产生不同函数
  - 编译器会对模板函数进行两次编译！！！
    - 在声明的地方对代码本身进行编译，在调用的地方对参数替换后的代码进行编译

- [类模板基本语法](00_函数模板/04_类模板基本语法.cpp)
  - 类模板声明
    - `template <typename Type>`
    - `class Test`
  - 类模板定义: 类模板是抽象的  需要具体化
	- `Test <int> a1(10), a2(20), a3(30);  // 类模板使用 必须初始化参数`
  - 类模板做函数参数 也需要具体化
    - `void useTest(Test <int> a)`

- [模板类派生普通类和模板类](00_函数模板/05_模板类派生普通类.cpp)
  - 需要模板类具体化，子类必须知道为父类分配多大内存空间
  - `class TestB : public Test<int>`

- 类模板的应用-复数类的实现
  - [模板类的方法都写在类的内部](00_函数模板/06_复数类_所有类的方法都在写类的内部.cpp)
  - [模板函数方法写在类的外部同一个cpp文件中](00_函数模板/06_复数类_模板类方法的外部实现_一个cpp中.cpp)
    - 友元函数重载模板类操作符的解决方法
    - 模板类友元函数滥用编译出错解决方法
  - [模板函数方法写在类的外部_h_hpp文件中](00_函数模板/07_模板类的外部实现_h_hpp.cpp)
    - 主调文件中需要包含cpp文件，改名hpp
    - 尽量写到一个文件中

- [类模板中的static关键字](00_函数模板/08_static关键字遇上模板类.cpp)
  - 模板类的静态成员变量每个类都拥有自己的静态成员变量(模板类的编译机制吻合)

- [MyVector实现](00_函数模板/09_MyVector_Test.cpp)
  - 初步实现