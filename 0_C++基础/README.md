# C++基础

> 关于C++基础部分的文件目录


## 目录

> C++对C的扩展
- [HelloWorld](#HelloWorld)
- [C++对C的加强](#C++对C的加强)
- [C和C++中的const](#C和C++中的const)
- [引用](#引用)
- [C++对C的函数扩展](#C++对C的函数扩展)

> 面向对象基础
- [类的封装](#面向对象基础)
- [构造函数和析构函数](#构造函数和析构函数)

## HelloWorld

- [C++ HelloWold 代码。](00_Helloword/00_Hello.cpp)
  - （有句话说的好，从HelloWorld到放弃）

## C++对C的加强

- [命名空间和iostream](01_namespace/00_namespace.cpp)
- [“实用性”增强](01_namespace/01_C++对C实用性增强.cpp)
  - C中定义必须在执行语句前，C++可以在任何位置
- [register关键字加强](01_namespace/02_register关键字的扩展.cpp)
  - C中不能对register取地址，C不对语句进行优化，C++可以对register取地址，且对语句做优化以加快执行速度
- [变量检测增强](01_namespace/03_变量检测增强.cpp)
  - C可以定义两个同名变量不报错，C++会报错
- [struct功能增强](01_namespace/04_struct功能增强.cpp)
  - C语言中认为struct定义了一组变量的集合，C++认为struct定义了一个性类型。
  - C++中对struct和class进行的操作是一样的,也有区别
- [变量和函数类型检测增强](01_namespace/05_变量_函数类型检查增强.cpp)
  - c++中函数必须有返回值类型，C语言可以没有，会有默认值‘
  - C++函数参数必须有类型，C语言可以没有。
- [新增bool类型](01_namespace/06_新增bool类型.cpp)
- [三目运算符](01_namespace/07_三目运算符.cpp)
  - C语言中表达式不能直接做左值，C++中可以

## C和C++中的const

- [C和C++中对const的实现](02_C语言和C++中的const/00_C和C++中const的实现.cpp)
  - C语言中const可以通过指针修改，C++中不能修改
  - C语言只是增加了一个不能修改的属性
  - C++放在了符号表中，不能以任何方式修改
- [C++中const和#define的异同](02_C语言和C++中的const/00_C和C++中const的实现.cpp)
  - 相同点
    - 可以用const替代#define使用
  - 不同点
    - const 由编译器提供处理，有变量检查和作用域
    - #define 由预处理器处理，只实现文本处理功能

## 引用
- [引用基础知识](03_引用/00_引用基础知识.cpp)
  - 已定义变量的别名
  - 语法：  TYPE& name = var;
  - 普通引用必须初始化，引用做函数参数不用初始化
  - 复杂类型的引用举例(struct)
  - C++中引用代替zhizhen？部分场合吧，引用可读性好
- [引用的本质](03_引用/01_引用的本质.cpp)
  - 引用本质： TYPE * cosnt var; // 必须初始化且占用一个指针的内存空间
  - 引用就是间接赋值的1-23模型
  - 引用使用时不必关注本质，分析语法现象时才考虑其常量指针的本质
- [函数返回值为引用(引用做左值或右值)](03_引用/02_函数返回值为引用(做左值右值).cpp)
  - 做右值时，临时堆栈变量不能使用函数返回引用初始化引用
  - 静态变量或全局变量可以使用函数返回引用初始化引用(既可以做左值也可以做右值)
  - 做左值时，函数返回被引用变量本身，可以做左值(必须是静态变量或者全局变量)
- [指针的引用](03_引用/03_指针的引用.cpp)
  - TYPE* &VarName
- [const引用](03_引用/04_const引用.cpp)
  - const 修饰变量引用, 给变量设置只读属性
  -  const 修饰常量（字面量）引用`const int& c = 50; `

## C++对C的函数扩展

- [inline内联函数](04_C++对C的函数扩展/00_inline内联函数.cpp)
  - 内联函数在编译时直接将函数体插入到函数调用地方
  - inline只是一种请求，编译器不一定允许这种操作
  - 内联函数省去了普通函数压栈、跳转和返回的开销
- [函数的默认参数](04_C++对C的函数扩展/01_函数的默认参数.cpp)
  - 函数的默认参数可以不传递，不传递则使用默认值
  - 默认参数必须放在非默认参数后面
- [函数的占位参数](04_C++对C的函数扩展/01_函数的默认参数.cpp)
  - 必须传递占位参数
- [函数的默认参数和占位参数](04_C++对C的函数扩展/01_函数的默认参数.cpp)
  - 可传递可不传递
  - 为以后业务开发留下线索？？
- [重载函数](04_C++对C的函数扩展/02_函数重载.cpp)
  - 函数名相同，参数不一样（类型和个数均不一样）,函数返回值的异同不能作为函数重载的判断依据
  - 重载函数本质上是相互独立的不同函数（静态链编）
  - 当重载遇上默认函数时，要注意去掉默认参数后参数类型和个数不能和已有重载函数相同，否则调用时可能会遇到重载不匹配
  - 重载函数与指针函数


## 类的封装

- [类的封装](05_面向对象基础/00_类的封装.cpp)
  - 对成员函数和成员属性进行封装
  - 对成员函数和成员属性进行访问控制
  - class 默认定义的属性是 private 在类外部不可见
  - struct 默认定义的属性是 public 在结构体外部可见
- [类的声明和定义分开实现](05_面向对象基础/01_类的声明和实现分开.cpp)
- 面向过程向面向对象转变案例
  - [立方体](05_面向对象基础/02_面向过程向面向对象转变案例立方体.cpp)
  - [圆点模型](05_面向对象基础/03_点圆模型.cpp)
  - [圆点模型2](05_面向对象基础/04_点圆模型2.cpp)

## 构造函数和析构函数
